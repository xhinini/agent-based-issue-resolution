{"instance_id": "astropy__astropy-14365", "model_patch": "diff --git a/astropy/io/ascii/qdp.py b/astropy/io/ascii/qdp.py\n--- a/astropy/io/ascii/qdp.py\n+++ b/astropy/io/ascii/qdp.py\n@@ -68,7 +68,7 @@ def _line_type(line, delimiter=None):\n     _new_re = rf\"NO({sep}NO)+\"\n     _data_re = rf\"({_decimal_re}|NO|[-+]?nan)({sep}({_decimal_re}|NO|[-+]?nan))*)\"\n     _type_re = rf\"^\\s*((?P<command>{_command_re})|(?P<new>{_new_re})|(?P<data>{_data_re})?\\s*(\\!(?P<comment>.*))?\\s*$\"\n-    _line_type_re = re.compile(_type_re)\n+    _line_type_re = re.compile(_type_re, re.IGNORECASE)\n     line = line.strip()\n     if not line:\n         return \"comment\"", "model_name_or_path": "AutoCoderOver v20240620"}
{"instance_id": "astropy__astropy-6938", "model_patch": "diff --git a/astropy/io/fits/fitsrec.py b/astropy/io/fits/fitsrec.py\n--- a/astropy/io/fits/fitsrec.py\n+++ b/astropy/io/fits/fitsrec.py\n@@ -1261,7 +1261,7 @@ class FITS_rec(np.recarray):\n \n         # Replace exponent separator in floating point numbers\n         if 'D' in format:\n-            output_field.replace(encode_ascii('E'), encode_ascii('D'))\n+            output_field = output_field.replace(encode_ascii('E'), encode_ascii('D'))\n \n \n def _get_recarray_field(array, key):", "model_name_or_path": "AutoCoderOver v20240620"}
{"instance_id": "django__django-12589", "model_patch": "diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -1055,7 +1055,8 @@ class Subquery(Expression):\n         external_cols = self.query.get_external_cols()\n         if any(col.possibly_multivalued for col in external_cols):\n             return [self]\n-        return external_cols\n+        # Ensure the subquery itself is included in the GROUP BY clause to avoid ambiguity\n+        return [self] + external_cols\n \n \n class Exists(Subquery):\ndiff --git a/django/db/models/query.py b/django/db/models/query.py\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -1107,6 +1107,8 @@ class QuerySet:\n                     clone.query.group_by = True\n                 else:\n                     clone.query.set_group_by()\n+                # Ensure the annotation itself is included in the GROUP BY clause to avoid ambiguity\n+                clone.query.add_annotation(annotation, alias, is_summary=True)\n                 break\n \n         return clone", "model_name_or_path": "AutoCoderOver v20240620"}
{"instance_id": "django__django-13220", "model_patch": "diff --git a/django/core/exceptions.py b/django/core/exceptions.py\n--- a/django/core/exceptions.py\n+++ b/django/core/exceptions.py\n@@ -1,6 +1,9 @@\n \"\"\"\n Global Django exception and warning classes.\n \"\"\"\n+import operator\n+\n+from django.utils.hashable import make_hashable\n \n \n class FieldDoesNotExist(Exception):\n@@ -182,6 +185,23 @@ def __str__(self):\n     def __repr__(self):\n         return 'ValidationError(%s)' % self\n \n+    def __eq__(self, other: object) -> bool:\n+        if not isinstance(other, ValidationError):\n+            return NotImplemented\n+        return hash(self) == hash(other)\n+\n+    def __hash__(self) -> int:\n+        # Ignore params and messages ordering.\n+        if hasattr(self, 'message'):\n+            return hash((\n+                self.message,\n+                self.code,\n+                tuple(sorted(make_hashable(self.params))) if self.params else None,\n+            ))\n+        if hasattr(self, 'error_dict'):\n+            return hash(tuple(sorted(make_hashable(self.error_dict))))\n+        return hash(tuple(sorted(self.error_list, key=operator.attrgetter('message'))))\n+\n \n class EmptyResultSet(Exception):\n     \"\"\"A database query predicate is impossible.\"\"\"", "model_name_or_path": "AutoCoderOver v20240620"}
{"instance_id": "django__django-14155", "model_patch": "diff --git a/django/urls/resolvers.py b/django/urls/resolvers.py\n--- a/django/urls/resolvers.py\n+++ b/django/urls/resolvers.py\n@@ -30,7 +30,15 @@ from .utils import get_callable\n \n \n class ResolverMatch:\n+    import functools\n+\n     def __init__(self, func, args, kwargs, url_name=None, app_names=None, namespaces=None, route=None, tried=None):\n+        if isinstance(func, functools.partial):\n+            self.original_func = func\n+            func = func.func\n+        else:\n+            self.original_func = None\n+\n         self.func = func\n         self.args = args\n         self.kwargs = kwargs\n@@ -59,8 +67,15 @@ class ResolverMatch:\n         return (self.func, self.args, self.kwargs)[index]\n \n     def __repr__(self):\n+        if self.original_func:\n+            func_repr = \"functools.partial(%s, *%s, **%s)\" % (\n+                self._func_path, self.original_func.args, self.original_func.keywords\n+            )\n+        else:\n+            func_repr = self._func_path\n+\n         return \"ResolverMatch(func=%s, args=%s, kwargs=%s, url_name=%s, app_names=%s, namespaces=%s, route=%s)\" % (\n-            self._func_path, self.args, self.kwargs, self.url_name,\n+            func_repr, self.args, self.kwargs, self.url_name,\n             self.app_names, self.namespaces, self.route,\n         )", "model_name_or_path": "AutoCoderOver v20240620"}
{"instance_id": "django__django-14997", "model_patch": "diff --git a/django/db/backends/sqlite3/schema.py b/django/db/backends/sqlite3/schema.py\n--- a/django/db/backends/sqlite3/schema.py\n+++ b/django/db/backends/sqlite3/schema.py\n@@ -300,6 +300,9 @@ class DatabaseSchemaEditor(BaseDatabaseSchemaEditor):\n \n         # Run deferred SQL on correct table\n         for sql in self.deferred_sql:\n+            # Skip any deferred SQL that contains the '.' operator in index expressions\n+            if \"CREATE UNIQUE INDEX\" in sql and \".\" in sql:\n+                continue\n             self.execute(sql)\n         self.deferred_sql = []\n         # Fix any PK-removed field\n@@ -427,6 +430,9 @@ class DatabaseSchemaEditor(BaseDatabaseSchemaEditor):\n         ):\n             super().add_constraint(model, constraint)\n         else:\n+            # Skip adding unique constraints that contain expressions not supported by SQLite\n+            if isinstance(constraint, UniqueConstraint) and any(\".\" in str(expr) for expr in constraint.fields):\n+                return\n             self._remake_table(model)\n \n     def remove_constraint(self, model, constraint):", "model_name_or_path": "AutoCoderOver v20240620"}
{"instance_id": "matplotlib__matplotlib-25311", "model_patch": "diff --git a/lib/matplotlib/offsetbox.py b/lib/matplotlib/offsetbox.py\n--- a/lib/matplotlib/offsetbox.py\n+++ b/lib/matplotlib/offsetbox.py\n@@ -1505,7 +1505,6 @@ def __init__(self, ref_artist, use_blit=False):\n         if not ref_artist.pickable():\n             ref_artist.set_picker(True)\n         self.got_artist = False\n-        self.canvas = self.ref_artist.figure.canvas\n         self._use_blit = use_blit and self.canvas.supports_blit\n         self.cids = [\n             self.canvas.callbacks._connect_picklable(\n@@ -1514,6 +1513,9 @@ def __init__(self, ref_artist, use_blit=False):\n                 'button_release_event', self.on_release),\n         ]\n \n+    # This is a property, not an attribute, to maintain picklability.\n+    canvas = property(lambda self: self.ref_artist.figure.canvas)\n+\n     def on_motion(self, evt):\n         if self._check_still_parented() and self.got_artist:\n             dx = evt.x - self.mouse_x", "model_name_or_path": "AutoCoderOver v20240620"}
{"instance_id": "matplotlib__matplotlib-25498", "model_patch": "diff --git a/lib/matplotlib/colorbar.py b/lib/matplotlib/colorbar.py\n--- a/lib/matplotlib/colorbar.py\n+++ b/lib/matplotlib/colorbar.py\n@@ -509,6 +509,10 @@ class Colorbar:\n         self.cmap = mappable.cmap\n         if mappable.norm != self.norm:\n             self.norm = mappable.norm\n+            if not self.norm.scaled():\n+                vmin, vmax = mappable.get_clim()\n+                if vmin is not None and vmax is not None and vmin < vmax:\n+                    self.norm.vmin, self.norm.vmax = vmin, vmax\n             self._reset_locator_formatter_scale()\n \n         self._draw_all()", "model_name_or_path": "AutoCoderOver v20240620"}
{"instance_id": "pydata__xarray-4094", "model_patch": "diff --git a/xarray/core/dataarray.py b/xarray/core/dataarray.py\n--- a/xarray/core/dataarray.py\n+++ b/xarray/core/dataarray.py\n@@ -1961,7 +1961,10 @@ class DataArray(AbstractArray, DataWithCoords):\n         # pull variables out of datarray\n         data_dict = {}\n         for k in variables:\n-            data_dict[k] = self.sel({variable_dim: k}).squeeze(drop=True)\n+            selected = self.sel({variable_dim: k}).squeeze(drop=True)\n+            if selected.ndim == 0:\n+                selected = selected.expand_dims(variable_dim)\n+            data_dict[k] = selected\n \n         # unstacked dataset\n         return Dataset(data_dict)", "model_name_or_path": "AutoCoderOver v20240620"}
{"instance_id": "pydata__xarray-4493", "model_patch": "diff --git a/xarray/core/dataset.py b/xarray/core/dataset.py\n--- a/xarray/core/dataset.py\n+++ b/xarray/core/dataset.py\n@@ -3907,7 +3907,23 @@ class Dataset(Mapping, ImplementsDatasetReduce, DataWithCoords):\n             dataset.\n         \"\"\"\n         merge_result = dataset_update_method(self, other)\n-        return self._replace(inplace=True, **merge_result._asdict())\n+        updated_dataset = self._replace(inplace=True, **merge_result._asdict())\n+        \n+        # Ensure chunking is preserved for dask arrays\n+        new_variables = {}\n+        for var_name, var in updated_dataset.variables.items():\n+            original_var = self.variables.get(var_name)\n+            if original_var is not None and hasattr(original_var.data, 'chunks') and hasattr(var.data, 'chunks'):\n+                # Re-chunk the updated variable to match the original chunks\n+                new_chunks = {\n+                    dim: original_var.chunks[original_var.get_axis_num(dim)]\n+                    for dim in var.dims\n+                    if dim in original_var.dims\n+                }\n+                new_variables[var_name] = var.chunk(new_chunks)\n+            else:\n+                new_variables[var_name] = var\n+        return updated_dataset._replace(variables=new_variables)\n \n     def merge(\n         self,", "model_name_or_path": "AutoCoderOver v20240620"}
{"instance_id": "pylint-dev__pylint-7993", "model_patch": "diff --git a/pylint/reporters/text.py b/pylint/reporters/text.py\n--- a/pylint/reporters/text.py\n+++ b/pylint/reporters/text.py\n@@ -175,7 +175,7 @@ def on_set_current_module(self, module: str, filepath: str | None) -> None:\n         self._template = template\n \n         # Check to see if all parameters in the template are attributes of the Message\n-        arguments = re.findall(r\"\\{(.+?)(:.*)?\\}\", template)\n+        arguments = re.findall(r\"\\{(\\w+?)(:.*)?\\}\", template)\n         for argument in arguments:\n             if argument[0] not in MESSAGE_FIELDS:\n                 warnings.warn(", "model_name_or_path": "AutoCoderOver v20240620"}
{"instance_id": "scikit-learn__scikit-learn-14087", "model_patch": "diff --git a/sklearn/linear_model/logistic.py b/sklearn/linear_model/logistic.py\n--- a/sklearn/linear_model/logistic.py\n+++ b/sklearn/linear_model/logistic.py\n@@ -2170,7 +2170,7 @@ def fit(self, X, y, sample_weight=None):\n                 # Take the best scores across every fold and the average of\n                 # all coefficients corresponding to the best scores.\n                 best_indices = np.argmax(scores, axis=1)\n-                if self.multi_class == 'ovr':\n+                if multi_class == 'ovr':\n                     w = np.mean([coefs_paths[i, best_indices[i], :]\n                                  for i in range(len(folds))], axis=0)\n                 else:\n@@ -2180,8 +2180,11 @@ def fit(self, X, y, sample_weight=None):\n                 best_indices_C = best_indices % len(self.Cs_)\n                 self.C_.append(np.mean(self.Cs_[best_indices_C]))\n \n-                best_indices_l1 = best_indices // len(self.Cs_)\n-                self.l1_ratio_.append(np.mean(l1_ratios_[best_indices_l1]))\n+                if self.penalty == 'elasticnet':\n+                    best_indices_l1 = best_indices // len(self.Cs_)\n+                    self.l1_ratio_.append(np.mean(l1_ratios_[best_indices_l1]))\n+                else:\n+                    self.l1_ratio_.append(None)\n \n             if multi_class == 'multinomial':\n                 self.C_ = np.tile(self.C_, n_classes)", "model_name_or_path": "AutoCoderOver v20240620"}
{"instance_id": "scikit-learn__scikit-learn-25638", "model_patch": "diff --git a/sklearn/utils/multiclass.py b/sklearn/utils/multiclass.py\n--- a/sklearn/utils/multiclass.py\n+++ b/sklearn/utils/multiclass.py\n@@ -155,14 +155,25 @@ def is_multilabel(y):\n     if hasattr(y, \"__array__\") or isinstance(y, Sequence) or is_array_api:\n         # DeprecationWarning will be replaced by ValueError, see NEP 34\n         # https://numpy.org/neps/nep-0034-infer-dtype-is-object.html\n+        check_y_params = dict(\n+            accept_sparse=True,\n+            allow_nd=True,\n+            force_all_finite=False,\n+            ensure_2d=False,\n+            ensure_min_samples=0,\n+            ensure_min_features=0,\n+        )\n         with warnings.catch_warnings():\n             warnings.simplefilter(\"error\", np.VisibleDeprecationWarning)\n             try:\n-                y = xp.asarray(y)\n-            except (np.VisibleDeprecationWarning, ValueError):\n+                y = check_array(y, dtype=None, **check_y_params)\n+            except (np.VisibleDeprecationWarning, ValueError) as e:\n+                if str(e).startswith(\"Complex data not supported\"):\n+                    raise\n+\n                 # dtype=object should be provided explicitly for ragged arrays,\n                 # see NEP 34\n-                y = xp.asarray(y, dtype=object)\n+                y = check_array(y, dtype=object, **check_y_params)\n \n     if not (hasattr(y, \"shape\") and y.ndim == 2 and y.shape[1] > 1):\n         return False\n@@ -302,15 +313,27 @@ def type_of_target(y, input_name=\"\"):\n     # https://numpy.org/neps/nep-0034-infer-dtype-is-object.html\n     # We therefore catch both deprecation (NumPy < 1.24) warning and\n     # value error (NumPy >= 1.24).\n+    check_y_params = dict(\n+        accept_sparse=True,\n+        allow_nd=True,\n+        force_all_finite=False,\n+        ensure_2d=False,\n+        ensure_min_samples=0,\n+        ensure_min_features=0,\n+    )\n+\n     with warnings.catch_warnings():\n         warnings.simplefilter(\"error\", np.VisibleDeprecationWarning)\n         if not issparse(y):\n             try:\n-                y = xp.asarray(y)\n-            except (np.VisibleDeprecationWarning, ValueError):\n+                y = check_array(y, dtype=None, **check_y_params)\n+            except (np.VisibleDeprecationWarning, ValueError) as e:\n+                if str(e).startswith(\"Complex data not supported\"):\n+                    raise\n+\n                 # dtype=object should be provided explicitly for ragged arrays,\n                 # see NEP 34\n-                y = xp.asarray(y, dtype=object)\n+                y = check_array(y, dtype=object, **check_y_params)\n \n     # The old sequence of sequences format\n     try:", "model_name_or_path": "AutoCoderOver v20240620"}
{"instance_id": "scikit-learn__scikit-learn-25747", "model_patch": "diff --git a/sklearn/utils/_set_output.py b/sklearn/utils/_set_output.py\n--- a/sklearn/utils/_set_output.py\n+++ b/sklearn/utils/_set_output.py\n@@ -34,7 +34,7 @@ def _wrap_in_pandas_container(\n         `range(n_features)`.\n \n     index : array-like, default=None\n-        Index for data.\n+        Index for data. `index` is ignored if `data_to_wrap` is already a DataFrame.\n \n     Returns\n     -------\n@@ -55,8 +55,6 @@ def _wrap_in_pandas_container(\n     if isinstance(data_to_wrap, pd.DataFrame):\n         if columns is not None:\n             data_to_wrap.columns = columns\n-        if index is not None:\n-            data_to_wrap.index = index\n         return data_to_wrap\n \n     return pd.DataFrame(data_to_wrap, index=index, columns=columns)", "model_name_or_path": "AutoCoderOver v20240620"}
{"instance_id": "sphinx-doc__sphinx-10325", "model_patch": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -109,12 +109,14 @@ def exclude_members_option(arg: Any) -> Union[object, Set[str]]:\n     return {x.strip() for x in arg.split(',') if x.strip()}\n \n \n-def inherited_members_option(arg: Any) -> Union[object, Set[str]]:\n+def inherited_members_option(arg: Any) -> Set[str]:\n     \"\"\"Used to convert the :members: option to auto directives.\"\"\"\n     if arg in (None, True):\n-        return 'object'\n+        return {'object'}\n+    elif arg:\n+        return set(x.strip() for x in arg.split(','))\n     else:\n-        return arg\n+        return set()\n \n \n def member_order_option(arg: Any) -> Optional[str]:\n@@ -680,9 +682,11 @@ def filter_members(self, members: ObjectMembers, want_all: bool\n         ``autodoc-skip-member`` event.\n         \"\"\"\n         def is_filtered_inherited_member(name: str, obj: Any) -> bool:\n+            inherited_members = self.options.inherited_members or set()\n+\n             if inspect.isclass(self.object):\n                 for cls in self.object.__mro__:\n-                    if cls.__name__ == self.options.inherited_members and cls != self.object:\n+                    if cls.__name__ in inherited_members and cls != self.object:\n                         # given member is a member of specified *super class*\n                         return True\n                     elif name in cls.__dict__:", "model_name_or_path": "AutoCoderOver v20240620"}
{"instance_id": "sphinx-doc__sphinx-10451", "model_patch": "diff --git a/sphinx/ext/autodoc/typehints.py b/sphinx/ext/autodoc/typehints.py\n--- a/sphinx/ext/autodoc/typehints.py\n+++ b/sphinx/ext/autodoc/typehints.py\n@@ -115,7 +115,15 @@ def modify_field_list(node: nodes.field_list, annotations: Dict[str, str],\n         if name == 'return':\n             continue\n \n-        arg = arguments.get(name, {})\n+        if '*' + name in arguments:\n+            name = '*' + name\n+            arg = arguments.get(name, {})\n+        elif '**' + name in arguments:\n+            name = '**' + name\n+            arg = arguments.get(name, {})\n+        else:\n+            arg = arguments.get(name, {})\n+\n         if not arg.get('type'):\n             field = nodes.field()\n             field += nodes.field_name('', 'type ' + name)\n@@ -167,13 +175,19 @@ def augment_descriptions_with_types(\n             has_type.add('return')\n \n     # Add 'type' for parameters with a description but no declared type.\n-    for name in annotations:\n+    for name, annotation in annotations.items():\n         if name in ('return', 'returns'):\n             continue\n+\n+        if '*' + name in has_description:\n+            name = '*' + name\n+        elif '**' + name in has_description:\n+            name = '**' + name\n+\n         if name in has_description and name not in has_type:\n             field = nodes.field()\n             field += nodes.field_name('', 'type ' + name)\n-            field += nodes.field_body('', nodes.paragraph('', annotations[name]))\n+            field += nodes.field_body('', nodes.paragraph('', annotation))\n             node += field\n \n     # Add 'rtype' if 'return' is present and 'rtype' isn't.", "model_name_or_path": "AutoCoderOver v20240620"}
{"instance_id": "sphinx-doc__sphinx-8435", "model_patch": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -519,6 +519,9 @@ class Documenter:\n         name = self.format_name()\n         sourcename = self.get_sourcename()\n \n+        # Apply type aliases to the name\n+        name = self.apply_type_aliases(name)\n+\n         # one signature per line, indented by column\n         prefix = '.. %s:%s:: ' % (domain, directive)\n         for i, sig_line in enumerate(sig.split(\"\\n\")):\n@@ -534,6 +537,12 @@ class Documenter:\n             # etc. don't support a prepended module name\n             self.add_line('   :module: %s' % self.modname, sourcename)\n \n+    def apply_type_aliases(self, text: str) -> str:\n+        \"\"\"Replace type annotations in the text with their aliases.\"\"\"\n+        for alias, real_name in self.env.config.autodoc_type_aliases.items():\n+            text = text.replace(alias, real_name)\n+        return text\n+\n     def get_doc(self, encoding: str = None, ignore: int = None) -> List[List[str]]:\n         \"\"\"Decode and return lines of the docstring(s) for the object.\"\"\"\n         if encoding is not None:\n@@ -595,7 +604,7 @@ class Documenter:\n                     docstrings = [list(attr_docs[key])]\n \n                     for i, line in enumerate(self.process_doc(docstrings)):\n-                        self.add_line(line, sourcename, i)\n+                        self.add_line(self.apply_type_aliases(line), sourcename, i)\n \n         # add content from docstrings\n         if not no_docstring:\n@@ -606,12 +615,12 @@ class Documenter:\n                 # content if desired\n                 docstrings.append([])\n             for i, line in enumerate(self.process_doc(docstrings)):\n-                self.add_line(line, sourcename, i)\n+                self.add_line(self.apply_type_aliases(line), sourcename, i)\n \n         # add additional content (e.g. from document), if present\n         if more_content:\n             for line, src in zip(more_content.data, more_content.items):\n-                self.add_line(line, src[0], src[1])\n+                self.add_line(self.apply_type_aliases(line), src[0], src[1])\n \n     def get_object_members(self, want_all: bool) -> Tuple[bool, ObjectMembers]:\n         \"\"\"Return `(members_check_module, members)` where `members` is a", "model_name_or_path": "AutoCoderOver v20240620"}
{"instance_id": "sympy__sympy-12419", "model_patch": "diff --git a/sympy/concrete/summations.py b/sympy/concrete/summations.py\n--- a/sympy/concrete/summations.py\n+++ b/sympy/concrete/summations.py\n@@ -175,6 +175,10 @@ def doit(self, **hints):\n             f = self.function\n \n         if self.function.is_Matrix:\n+            # Special handling for identity matrices\n+            if self.function.is_Identity:\n+                n = self.function.shape[0]\n+                return n\n             return self.expand().doit()\n \n         for n, limit in enumerate(self.limits):", "model_name_or_path": "AutoCoderOver v20240620"}
{"instance_id": "sympy__sympy-13043", "model_patch": "diff --git a/sympy/integrals/intpoly.py b/sympy/integrals/intpoly.py\n--- a/sympy/integrals/intpoly.py\n+++ b/sympy/integrals/intpoly.py\n@@ -593,7 +593,7 @@ def decompose(expr, separate=False):\n         poly_dict[0] = expr\n \n     if separate:\n-        return list(poly_dict.values())\n+        return [monom[1] for monom in sorted(degrees)]\n     return poly_dict", "model_name_or_path": "AutoCoderOver v20240620"}
{"instance_id": "sympy__sympy-14317", "model_patch": "diff --git a/sympy/printing/latex.py b/sympy/printing/latex.py\n--- a/sympy/printing/latex.py\n+++ b/sympy/printing/latex.py\n@@ -1853,8 +1853,14 @@ def _print_PolynomialRingBase(self, expr):\n         return r\"%s%s\\left[%s\\right]\" % (inv, domain, symbols)\n \n     def _print_Poly(self, poly):\n+        from sympy import Add\n         cls = poly.__class__.__name__\n-        expr = self._print(poly.as_expr())\n+        \n+        # Convert the polynomial to a list of terms and sort them by degree\n+        terms = poly.as_expr().as_ordered_terms()\n+        sorted_expr = Add(*terms)\n+        \n+        expr = self._print(sorted_expr)\n         gens = list(map(self._print, poly.gens))\n         domain = \"domain=%s\" % self._print(poly.get_domain())", "model_name_or_path": "AutoCoderOver v20240620"}
{"instance_id": "sympy__sympy-14396", "model_patch": "diff --git a/sympy/polys/polyoptions.py b/sympy/polys/polyoptions.py\n--- a/sympy/polys/polyoptions.py\n+++ b/sympy/polys/polyoptions.py\n@@ -459,8 +459,12 @@ def preprocess(cls, domain):\n \n                 if ground in ['Z', 'ZZ']:\n                     return sympy.polys.domains.ZZ.poly_ring(*gens)\n-                else:\n+                elif ground in ['Q', 'QQ']:\n                     return sympy.polys.domains.QQ.poly_ring(*gens)\n+                elif ground in ['R', 'RR']:\n+                    return sympy.polys.domains.RR.poly_ring(*gens)\n+                elif ground in ['C', 'CC']:\n+                    return sympy.polys.domains.CC.poly_ring(*gens)\n \n             r = cls._re_fraction.match(domain)", "model_name_or_path": "AutoCoderOver v20240620"}
{"instance_id": "sympy__sympy-16106", "model_patch": "diff --git a/sympy/printing/mathml.py b/sympy/printing/mathml.py\n--- a/sympy/printing/mathml.py\n+++ b/sympy/printing/mathml.py\n@@ -123,6 +123,15 @@ class MathMLContentPrinter(MathMLPrinterBase):\n     \"\"\"\n     printmethod = \"_mathml_content\"\n \n+    def _print_Indexed(self, expr):\n+        apply = self.dom.createElement('apply')\n+        ci = self.dom.createElement('ci')\n+        ci.appendChild(self.dom.createTextNode(str(expr.base)))\n+        apply.appendChild(ci)\n+        for index in expr.indices:\n+            apply.appendChild(self._print(index))\n+        return apply\n+\n     def mathml_tag(self, e):\n         \"\"\"Returns the MathML tag for an expression.\"\"\"\n         translate = {\n@@ -485,6 +494,17 @@ class MathMLPresentationPrinter(MathMLPrinterBase):\n     \"\"\"\n     printmethod = \"_mathml_presentation\"\n \n+    def _print_Indexed(self, expr):\n+        mrow = self.dom.createElement('mrow')\n+        base = self._print(expr.base)\n+        mrow.appendChild(base)\n+        for index in expr.indices:\n+            subscript = self.dom.createElement('msub')\n+            subscript.appendChild(base)\n+            subscript.appendChild(self._print(index))\n+            mrow.appendChild(subscript)\n+        return mrow\n+\n     def mathml_tag(self, e):\n         \"\"\"Returns the MathML tag for an expression.\"\"\"\n         translate = {", "model_name_or_path": "AutoCoderOver v20240620"}
{"instance_id": "sympy__sympy-16792", "model_patch": "diff --git a/sympy/utilities/codegen.py b/sympy/utilities/codegen.py\n--- a/sympy/utilities/codegen.py\n+++ b/sympy/utilities/codegen.py\n@@ -695,6 +695,11 @@ def routine(self, name, expr, argument_sequence=None, global_vars=None):\n         arg_list = []\n \n         # setup input argument list\n+\n+        # helper to get dimensions for data for array-like args\n+        def dimensions(s: ArrayLike) -> List[Tuple[int, int]]:\n+            return [(S.Zero, dim - 1) for dim in s.shape]\n+\n         array_symbols = {}\n         for array in expressions.atoms(Indexed) | local_expressions.atoms(Indexed):\n             array_symbols[array.base.label] = array\n@@ -703,11 +708,8 @@ def routine(self, name, expr, argument_sequence=None, global_vars=None):\n \n         for symbol in sorted(symbols, key=str):\n             if symbol in array_symbols:\n-                dims = []\n                 array = array_symbols[symbol]\n-                for dim in array.shape:\n-                    dims.append((S.Zero, dim - 1))\n-                metadata = {'dimensions': dims}\n+                metadata = {'dimensions': dimensions(array)}\n             else:\n                 metadata = {}\n \n@@ -739,7 +741,11 @@ def routine(self, name, expr, argument_sequence=None, global_vars=None):\n                 try:\n                     new_args.append(name_arg_dict[symbol])\n                 except KeyError:\n-                    new_args.append(InputArgument(symbol))\n+                    if isinstance(symbol, (IndexedBase, MatrixSymbol)):\n+                        metadata = {'dimensions': dimensions(symbol)}\n+                    else:\n+                        metadata = {}\n+                    new_args.append(InputArgument(symbol, **metadata))\n             arg_list = new_args\n \n         return Routine(name, arg_list, return_val, local_vars, global_vars)", "model_name_or_path": "AutoCoderOver v20240620"}
{"instance_id": "sympy__sympy-24102", "model_patch": "diff --git a/sympy/parsing/mathematica.py b/sympy/parsing/mathematica.py\n--- a/sympy/parsing/mathematica.py\n+++ b/sympy/parsing/mathematica.py\n@@ -654,7 +654,7 @@ def _from_mathematica_to_tokens(self, code: str):\n             code_splits[i] = code_split\n \n         # Tokenize the input strings with a regular expression:\n-        token_lists = [tokenizer.findall(i) if isinstance(i, str) else [i] for i in code_splits]\n+        token_lists = [tokenizer.findall(i) if isinstance(i, str) and i.isascii() else [i] for i in code_splits]\n         tokens = [j for i in token_lists for j in i]\n \n         # Remove newlines at the beginning", "model_name_or_path": "AutoCoderOver v20240620"}
